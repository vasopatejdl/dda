#!/usr/bin/env node

const { exit } = require('process');

const [major, minor, patch] = process.version.substring(1).split('.');
if (major < 15) {
  console.log('Please upgrade to node v16 if you encounter any issues.');
  exit(1);
}

const fs = require('fs');
const path = require('path');
const { parseManifest } = require('../dist/lib');
const colors = require('ansi-colors');
const sdkPackage = require('../package.json');
const { prompt } = require('enquirer');
const { execSync } = require('child_process');

const warning = colors.yellow;
const success = colors.green;
const error = colors.red;
const bold = colors.bold;

const readmeIgnoreAfterMarker = '<!-- ignore-after -->';

function logRequirement(requirement, message = '', status = 'error') {
  const color =
    status == 'fulfilled' ? success : status == 'recommended' ? warning : error;
  console.log(bold(requirement + ': ') + color(message));
  return status != 'error';
}

function findPluginBasePath() {
  // TODO: Error check
  return execSync('git rev-parse --show-toplevel', {
    encoding: 'utf-8',
  }).trim();
}

function getRepoUrlFromGitRepo() {
  const gitRemote = execSync('git remote -vv', { encoding: 'utf-8' });
  const userRepoRegex = /origin\s*git@github\.com:(.*)\.git\s*\(fetch\)/g;
  const match = userRepoRegex.exec(gitRemote);
  if (!match) return undefined;

  const userRepo = match[1];
  const repoUrl = `https://github.com/${userRepo}`;

  return repoUrl;
}

function parseReadme(pluginPath) {
  const readmePath = path.join(pluginPath, 'README.md');
  const hasReadme = fs.existsSync(readmePath);
  if (hasReadme) {
    const readme = fs.readFileSync(readmePath, 'utf-8');
    if (readme.includes(readmeIgnoreAfterMarker)) {
      const [pluginReadme, sdkReadme] = readme.split(readmeIgnoreAfterMarker);
      return { hasReadme, pluginReadme: pluginReadme.trim(), sdkReadme };
    } else {
      return { hasReadme, pluginReadme: readme };
    }
  } else {
    return { hasReadme };
  }
}

function validateREADME(pluginPath) {
  let ok = true;
  const { hasReadme, pluginReadme } = parseReadme(pluginPath);

  if (hasReadme) {
    if (!pluginReadme) {
      ok =
        ok &&
        logRequirement(
          'README',
          'Missing plugin README. ' + bold('npx remnote-plugin init'),
        );
    } else {
      ok = ok && logRequirement('README', 'Custom Readme', 'fulfilled');
    }
    // TODO: Further checks?
  } else {
    ok =
      ok &&
      logRequirement(
        'README',
        'Create README.md. ' + bold('npx remnote-plugin init'),
      );
  }
  return ok;
}

function validateManifest(pluginPath) {
  let ok = true;
  const manifestData = fs.readFileSync(
    path.join(pluginPath, 'public', 'manifest.json'),
    'utf-8',
  );
  const manifestJson = JSON.parse(manifestData);
  const manifest = parseManifest(manifestJson);
  if (!manifest.success) {
    ok = ok && logRequirement('Manifest');
    manifest.errors.forEach(({ field, message }) =>
      logRequirement(`  ${field}`, message),
    );
  } else {
    // TODO: Recommended entries
    ok = ok && logRequirement('Manifest', 'OK', 'fulfilled');
  }
  return ok;
}

function validateAssets(pluginPath) {
  let ok = true;
  const assets = fs.readdirSync(path.join(pluginPath, 'public'));
  const hasSVGLogo = assets.includes('logo.svg');
  const hasPngLogo = assets.includes('logo.png');

  if (hasSVGLogo) {
    ok = ok && logRequirement('Logo', 'SVG', 'fulfilled');
  } else if (hasPngLogo) {
    ok = ok && logRequirement('Logo', 'PNG', 'fulfilled');
  } else {
    // ok = ok && logRequirement(
    //   'Logo',
    //   'Create ' + colors.bold('public/logo.svg'),
    //   // TODO: Reimplement autogenerated logos.
    //   // 'recommended',
    // );
    console.log(colors.dim('  Using autogenerated logo.'));
  }

  //ok = ok && logRequirement('Banner', 'TODO', 'recommended');
  return ok;
}

async function initPlugin(pluginPath) {
  console.log('Initialising plugin in', bold(pluginPath), '...');
  console.log();

  let response;
  try {
    response = await prompt([
      {
        type: 'input',
        name: 'author',
        message: 'Author Name?',
      },
      {
        type: 'input',
        name: 'name',
        message: 'Title of the plugin?',
      },
      {
        type: 'input',
        name: 'description',
        message: 'Describe your plugin in 1-2 sentences:',
      },

      {
        type: 'confirm',
        name: 'enableOnMobile',
        message: 'Do you plan to support mobile apps?',
      },
    ]);
  } catch (e) {
    // Ignore Ctrl + C
    return;
  }
  const manifest = {
    ...response,

    // TODO: Do we want readable ids?
    id: `${response.author}-${Math.random().toString(36).substr(2, 7)}`,
    manifestVersion: 1,
    repoUrl: getRepoUrlFromGitRepo(),
    version: {
      major: 0,
      minor: 0,
      patch: 1,
    },
    requestNative: false,
    requiredScopes: [
      {
        type: 'All',
        level: 'Read',
      },
    ],
  };
  createManifest(pluginPath, manifest);
  createReadme(pluginPath, manifest);
}

function createManifest(pluginPath, manifest) {
  fs.writeFileSync(
    path.join(pluginPath, 'public/manifest.json'),
    JSON.stringify(manifest, null, 2),
  );
}

function createReadme(pluginPath, manifest) {
  const { hasReadme, pluginReadme, sdkReadme } = parseReadme(pluginPath);

  if (!hasReadme) {
    fs.writeFileSync(
      path.join(pluginPath, 'README.md'),
      formatPluginReadme(manifest),
    );
  } else if (pluginReadme) {
    console.log('README.md: Already exists.');
  } else {
    fs.writeFileSync(
      path.join(pluginPath, 'README.md'),
      formatPluginReadme(manifest) + sdkReadme,
    );
  }
}

function formatPluginReadme(manifest) {
  // TODO: Logo
  // TODO: Banner
  // TODO: Badges
  // TODO: Other?

  return `# ${manifest.name}

${manifest.description}

## Usage

<!-- TODO: Describe usage -->

${readmeIgnoreAfterMarker}
`;
}

const main = async () => {
  const pluginPath = findPluginBasePath();
  if (!pluginPath) {
    console.log('Must run inside a RemNote plugin git repository!');
    exit(1);
  }

  console.log(bold('@remnote/plugin-sdk:'), sdkPackage.version);
  console.log(bold('Plugin path:'), pluginPath);
  console.log();

  if (process.argv[2] == 'init') {
    await initPlugin(pluginPath);
    validateManifest(pluginPath);
  } else {
    const results = [
      validateREADME(pluginPath),
      validateAssets(pluginPath),
      validateManifest(pluginPath),
    ];

    if (!results.every((x) => x)) {
      console.log(bold('\nPlease fix errors before uploading!'));
      exit(1);
    } else {
      console.log('All good!');
    }
  }
};

main();
